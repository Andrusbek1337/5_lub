# Лабороторная работа по дисциплине "Язык программирования C++"

# ЛАБОРАТОРНАЯ РАБОТА №5 ФАЙЛЫ

# Вариант: 7

# Группа: ИТ-5-2024

# ФИО: Шалашов Андрей юрьевич

# Описание лабораторной работы:

Выполнить все задания в одном проекте в виде статических методов одного класса.В задании 1 и 2 бинарные файлы, содержат числовые данные, исходный файл необходимо заполнитьслучайными данными, заполнение организовать отдельным методом.В задании 3 бинарные файлы содержат величины типа struct, заполнение исходного файланеобходимо организовать отдельным методом.В задании 4 в текстовом файле хранятся целые числа по одному в строке, исходный файлнеобходимо заполнить случайными данными, заполнение организовать отдельным методом.В задании 5 в текстовом файле хранятся целые числа по несколько в строке, исходный файлнеобходимо заполнить случайными данными, заполнение организовать отдельным методом.В задании 6 в текстовом файле хранится текст.

# Задание 1. Бинарные файлы: Найти разность максимального и минимального элементов заданного файла.

##### Поля (данные)
    filename - имя бинарного файла с целыми числами

##### Локальные переменные:
    minVal - минимальное значение
    maxVal - максимальное значение
    num - текущее считанное число

##### Методы
    static int task1(const std::string& filename);
    static void createBinaryFileWithRandomData(const std::string& filename, int count);

##### Алгоритм решения
    Создание файла (createBinaryFileWithRandomData):
    Открыть файл в бинарном режиме для записи
    Сгенерировать count случайных чисел (0-99)
    Записать каждое число в файл с помощью write
    Обработка файла (task1):
    Открыть файл в бинарном режиме для чтения
    Инициализировать minVal = INT_MAX, maxVal = INT_MIN
    Пока читаются числа из файла:
    Считать очередное число
    Если число < minVal, обновить minVal
    Если число > maxVal, обновить maxVal
    Проверить, что файл не пуст
    Вернуть maxVal - minVal

#### Тестирование
<img width="588" height="36" alt="image" src="https://github.com/user-attachments/assets/9910b3b5-fa1b-4acd-9cb9-8ee8d585628e" />

# Задание 2. Бинарные файлы: Скопировать элементы заданного файла в квадратную матрицу размером n×n (если элементов файла недостает, заполнить оставшиеся элементы матрицы нулями). Заменить на нуль все вхождения максимального элемента.

##### Поля (данные)
    filename - имя бинарного файла
    n - размер квадратной матрицы

##### Локальные переменные:
    matrix - двумерный вектор vector<vector<int>>
    elements - вектор считанных чисел
    maxElement - максимальный элемент
    num - текущее число

##### Методы
    static std::vector<std::vector<int>> task2(const std::string& filename, int n);

##### Алгоритм решения
    Создание файла: используется тот же метод createBinaryFileWithRandomData
    Обработка файла (task2):
    Открыть файл в бинарном режиме для чтения
    Создать матрицу n × n, заполненную нулями
    Прочитать все числа из файла в вектор elements, попутно находя maxElement
    Заполнить матрицу:
    Для индекса i от 0 до min(elements.size(), n*n) - 1:
    matrix[i / n][i % n] = elements[i]
    Заменить все вхождения maxElement на 0:
    Двойной цикл по всем элементам матрицы
    Если matrix[i][j] == maxElement, присвоить 0
    Вернуть матрицу
    
#### Тестирование
<img width="843" height="151" alt="image" src="https://github.com/user-attachments/assets/9d7953d3-8335-4ebf-bc87-08b8d97ec086" />

# Задание 3. Бинарные файлы и структуры: Файл содержит сведения об игрушках: название игрушки, ее стоимость в рублях и возрастныеграницы (например, игрушка может предназначаться для детей от двух до пяти лет). Вывестиназвания наиболее дорогих игрушек (цена которых отличается от цены самой дорогой игрушкине более, чем на k руб.).

##### Поля (данные)
    Структура Toy:
    name (string) - название игрушки
    price (int) - стоимость в рублях
    minAge (int) - минимальный возраст
    maxAge (int) - максимальный возраст

##### Параметры метода:
    filename - имя бинарного файла
    k - допустимое отклонение от максимальной цены

##### Локальные переменные:
    toys - вектор структур Toy
    maxPrice - максимальная цена среди всех игрушек
    result - вектор названий игрушек, удовлетворяющих условию
    
##### Методы
    static std::vector<std::string> task3(const std::string& filename, int k);
    static void createBinaryFileWithToys(const std::string& filename, int count);

##### Алгоритм решения
    Создание файла (createBinaryFileWithToys):
    Открыть файл в бинарном режиме
    Для каждой игрушки от 0 до count-1:
    Случайно выбрать название из массива
    Сгенерировать случайную цену (100-1000)
    Сгенерировать случайные возрастные границы
    Записать в файл: [длина имени][имя][цена][minAge][maxAge]
    Обработка файла (task3):
    Открыть файл в бинарном режиме для чтения
    Пока не конец файла:
    Прочитать длину имени
    Прочитать имя указанной длины
    Прочитать price, minAge, maxAge
    Добавить игрушку в вектор toys
    Обновить maxPrice если нужно
    Пройти по всем игрушкам:
    Если maxPrice - toy.price <= k, добавить toy.name в результат
    Вернуть вектор названий

#### Тестирование
<img width="1063" height="71" alt="image" src="https://github.com/user-attachments/assets/9c5943c3-1088-4a6c-b352-4a49b8ac6217" />

# Задание 4. Текстовые файлы: Подсчитать количество вхождений максимального элемента в файл.

##### Поля (данные)
    filename - имя текстового файла (по одному числу в строке)

##### Локальные переменные:
    numbers - вектор всех чисел
    maxElement - максимальное число
    count - счетчик вхождений
    num - текущее число

##### Методы
    static int task4(const std::string& filename);
    static void createTextFileOnePerLine(const std::string& filename, int count);

##### Алгоритм решения
    Создание файла (createTextFileOnePerLine):
    Открыть текстовый файл
    Сгенерировать count случайных чисел
    Записать каждое число на новой строке
    Обработка файла (task4):
    Открыть текстовый файл для чтения
    Читать числа, пока есть данные:
    Добавить число в вектор numbers
    Если число > maxElement, обновить maxElement
    Пройти по вектору numbers:
    Если число == maxElement, увеличить count
    Вернуть count

#### Тестирование
<img width="659" height="36" alt="image" src="https://github.com/user-attachments/assets/922b279d-f5b2-4bb1-a2c4-128997da21ab" />

# Задание 5. Текстовые файлы: Вычислить количество чётных элементов

##### Поля (данные)
    filename - имя текстового файла (несколько чисел в строке)

##### Локальные переменные:
    evenCount - счетчик чётных чисел
    line - текущая строка
    num - текущее число

##### Методы
    static int task5(const std::string& filename);
    static void createTextFileMultiplePerLine(const std::string& filename, int count, int numbersPerLine);

##### Алгоритм решения
    Создание файла (createTextFileMultiplePerLine):
    Открыть текстовый файл
    Для каждой из count строк:
    Сгенерировать numbersPerLine случайных чисел
    Записать их в строку через пробел
    Обработка файла (task5):
    Открыть текстовый файл для чтения
    Инициализировать evenCount = 0
    Читать файл построчно:
    Создать istringstream из строки
    Читать числа из потока:
    Если число чётное (num % 2 == 0), увеличить evenCount
    Вернуть evenCount

#### Тестирование
<img width="452" height="46" alt="image" src="https://github.com/user-attachments/assets/edeafedc-9640-471b-8019-0d8abe842557" />

# Задание 6. Текстовые файлы: Переписать в другой файл строки, содержащие заданную комбинацию символов. Например,строка «Сегодня старшеклассники выполняли ЕГЭ по информатике и ИКТ» содержиткомбинацию «форма».

##### Поля (данные)
    inputFilename - имя исходного текстового файла
    outputFilename - имя результирующего файла
    substring - искомая комбинация символов

##### Локальные переменные:
    line - текущая строка из входного файла

##### Методы
    static void task6(const std::string& inputFilename, const std::string& outputFilename, const std::string& substring);
    static void createTextFileWithText(const std::string& filename);

##### Алгоритм решения
    Создание файла (createTextFileWithText):
    Открыть текстовый файл
    Записать заранее подготовленные строки (некоторые содержат слово "форма")
    Обработка файла (task6):
    Открыть входной файл для чтения
    Открыть выходной файл для записи
    Читать входной файл построчно:
    Проверить, содержит ли строка искомую подстроку (line.find(substring) != string::npos)
    Если содержит, записать строку в выходной файл
    Закрыть оба файла
    
#### Тестирование
<img width="1005" height="145" alt="image" src="https://github.com/user-attachments/assets/d0fd6f1c-80b9-467b-92d1-e7a62ab90d0c" />
